# TIL - 2018.05.11

## STDS 

1. Merge Sort 구현
	[code link](https://github.com/rrbb014/TIL/blob/master/tip/20180511_merge_sort_mine.py)
	
	생각해보니 merge sort를 구현해본적이 있나? 싶을 정도로 헤맨 코드.
	<br>
	결국 위키피디아의 pseudo code의 힘을 빌어 구현함.
	<br>
	external merge sort를 구현해보는 것도 STDS에 포함시켜야 겠다.
	<br>
	
2. Codility Lesson 04 - FrogRiverOne 다시 풀기
	
	총 23분 소요.
	<br>
	테스트함수랑 케이스 구현에 19분 + 솔루션 구현 및 테스트 모두 통과하는데 4분.
	<br>
	corner case가 무엇이 있을까, 내가 못 짚고 넘어가는 case가 있을까 하는 부분에서 테스트케이스를
	<br>
	고심하는데 시간을 소비했다. 결과가 올그린이라 다행ㅎㅎ

	[result link](https://app.codility.com/demo/results/trainingRWMY7M-XNW/)
	- task : 100
	- correctness : 100
	- performance : 100
	
3. Codility Lesson 05 - CountDiv 다시 풀기
	
	**1st code** 

	[result link](https://app.codility.com/demo/results/trainingVKYFSS-GZK/)
	- task : 75
	- correctness : 75
	- performance : 75
	
	총 22분 소요.
	<br>
	테스트함수&케이스 구현 12분 + 솔루션 구현 & 테스트검증 10분.
	<br>
	이번 문제는 로직검증을 완전히 못한 찝찝함이 남은 채로 코드를 제출함.
	<br>
	그래서 인지.. 2개의 실제 테스트 오류가 있었음.
	
	**2nd code**
	
	[result link](https://app.codility.com/demo/results/trainingJHFJP7-2S9/)
	- task : 100
	- correctness : 100
	- performance : 100
	
	좀 어리둥절하게 해결한 문제.
	<br>
	제약사항이 O(1) 이라 분명 세련된 공식이 있을 것 같은데, 
	<br>
	만약, B-A보다 K가 큰 경우엔 여지없이 오류가 나는 부분을 어떻게 해결할까 하다가
	<br>
	B // K 와 A // K의 몫을 이용하면 이러한 상황에서도 해결할 수 있지않을까 했는데
	<br>
	random case와 corner case 모두 무사히 통과했지만 반신반의 했음.
	<br>
	올 그린이 뜨고나서 과거에 어떻게 풀었는지 살펴봤는데([과거의 해결](https://github.com/rrbb014/TIL/blob/master/codility-lessons/Lesson05_prefix_sums/L05_CountDiv.md)) 신기하게 제출한 솔루션과 똑같은 로직으로
	<br>
	해결한 것을 보고 이전에 풀었던 로직이 기억 어딘가에 남아있었나 보다.. 라고 생각됨.
	<br>
	그래도 스스로 시행착오 끝에 생각해낸 것을 아주 칭찬해~~
	<br>
	왜 이 방식이 통하는지 다시한번 살펴보자!
	
	